<!DOCTYPE html>

<head>
    <meta charset="UTF-8">
    <title>WÃ¼rfel</title>
    <script src="lib/gl-matrix.js"></script>
    <link href="https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css" rel="stylesheet">
</head>

<body class="h-screen">
    <div class="flex justify-center items-center h-full">
        <canvas id="canvas" class="h-auto w-auto"></canvas>
    </div>

    <script>
        var vertexShaderSource = `
       precision mediump float;

       attribute vec3 position;
       attribute vec3 normal;

       uniform mat4 Model;
       uniform mat4 View;
       uniform mat4 Projection;
       uniform mat4 normalMatrix;

       varying vec3 normal_out;
     
       void main(){
           gl_Position = Projection * View * Model * vec4(position, 1.0);
           normal_out = (normalMatrix * vec4(normal, 1.0)).xyz;

       }
       `
        var fragmentShaderSource = `
       precision mediump float;

       uniform vec3 lightDir;

       varying vec3 normal_out;

       void main(){
        
           float lightInt = max(dot(normal_out, -lightDir), 0.0);
           gl_FragColor = vec4(0.5*lightInt, 0.5*lightInt, 0.5*lightInt, 1.0);
       }
       `

        var InitGL = function () {
            var canvas = document.getElementById("canvas")
            var context = canvas.getContext("experimental-webgl")
            if (!context) {
                alert("Browser does not support WebGL.")
            }

            context.clearColor(0.2, 0.3, 0.8, 1.0)
            context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT)

            //create shaders
            var vertexShader = context.createShader(context.VERTEX_SHADER);
            var fragmentShader = context.createShader(context.FRAGMENT_SHADER);

            context.shaderSource(vertexShader, vertexShaderSource);
            context.shaderSource(fragmentShader, fragmentShaderSource);

            context.compileShader(vertexShader)
            if (!context.getShaderParameter(vertexShader, context.COMPILE_STATUS)) {
                console.error("Error compiling the vertex shader.", context.getShaderInfoLog(vertexShader))
                return
            }

            context.compileShader(fragmentShader)
            if (!context.getShaderParameter(fragmentShader, context.COMPILE_STATUS)) {
                console.error("Error compiling the fragment shader.", context.getShaderInfoLog(fragmentShader))
                return
            }

            //create program, link and check for possible errors
            var program = context.createProgram()
            context.attachShader(program, vertexShader)
            context.attachShader(program, fragmentShader)
            context.linkProgram(program)
            if (!context.getProgramParameter(program, context.LINK_STATUS)) {
                console.error("Error linking program.", context.getProgramInfoLog(program))
                return
            }
            context.validateProgram(program)
            if (!context.getProgramParameter(program, context.VALIDATE_STATUS)) {
                console.error("Error validating program.", context.getProgramInfoLog(program))
                return
            }

            //create model data and buffers
            //position 3f, texcoords 2f, normals 3f
            var cube = [
                -0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, -1.0,
                0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, -1.0,
                0.5, 0.5, -0.5, 1.0, 1.0, 0.0, 0.0, -1.0, //hinten
                0.5, 0.5, -0.5, 1.0, 1.0, 0.0, 0.0, -1.0,
                -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, -1.0,
                -0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, -1.0,

                -0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 1.0,
                0.5, -0.5, 0.5, 1.0, 0.0, 0.0, 0.0, 1.0,
                0.5, 0.5, 0.5, 1.0, 1.0, 0.0, 0.0, 1.0,
                0.5, 0.5, 0.5, 1.0, 1.0, 0.0, 0.0, 1.0, //vorne	
                -0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 1.0,
                -0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 1.0,

                -0.5, 0.5, 0.5, 1.0, 0.0, -1.0, 0.0, 0.0,
                -0.5, 0.5, -0.5, 1.0, 1.0, -1.0, 0.0, 0.0,
                -0.5, -0.5, -0.5, 0.0, 1.0, -1.0, 0.0, 0.0,
                -0.5, -0.5, -0.5, 0.0, 1.0, -1.0, 0.0, 0.0,//links
                -0.5, -0.5, 0.5, 0.0, 0.0, -1.0, 0.0, 0.0,
                -0.5, 0.5, 0.5, 1.0, 0.0, -1.0, 0.0, 0.0,

                0.5, 0.5, 0.5, 1.0, 0.0, 1.0, 0.0, 0.0,
                0.5, 0.5, -0.5, 1.0, 1.0, 1.0, 0.0, 0.0,
                0.5, -0.5, -0.5, 0.0, 1.0, 1.0, 0.0, 0.0,//rechts
                0.5, -0.5, -0.5, 0.0, 1.0, 1.0, 0.0, 0.0,
                0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0,
                0.5, 0.5, 0.5, 1.0, 0.0, 1.0, 0.0, 0.0,

                -0.5, -0.5, -0.5, 0.0, 1.0, 0.0, -1.0, 0.0,
                0.5, -0.5, -0.5, 1.0, 1.0, 0.0, -1.0, 0.0,
                0.5, -0.5, 0.5, 1.0, 0.0, 0.0, -1.0, 0.0,//unten
                0.5, -0.5, 0.5, 1.0, 0.0, 0.0, -1.0, 0.0,
                -0.5, -0.5, 0.5, 0.0, 0.0, 0.0, -1.0, 0.0,
                -0.5, -0.5, -0.5, 0.0, 1.0, 0.0, -1.0, 0.0,

                -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 1.0, 0.0,
                0.5, 0.5, -0.5, 1.0, 1.0, 0.0, 1.0, 0.0,
                0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,//oben
                0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,
                -0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0,
                -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 1.0, 0.0
            ]
            var vertexBuffer = context.createBuffer()
            context.bindBuffer(context.ARRAY_BUFFER, vertexBuffer)
            context.bufferData(context.ARRAY_BUFFER, new Float32Array(cube), context.STATIC_DRAW)
            var positionAttribLocation = context.getAttribLocation(program, 'position')
            var normalAttribLocation = context.getAttribLocation(program, 'normal')
            context.vertexAttribPointer(
                positionAttribLocation,
                3,
                context.FLOAT,
                context.FALSE,
                8 * Float32Array.BYTES_PER_ELEMENT,
                0
            )
            context.vertexAttribPointer(
                normalAttribLocation,
                3,
                context.FLOAT,
                context.FALSE,
                8 * Float32Array.BYTES_PER_ELEMENT,
                5 * Float32Array.BYTES_PER_ELEMENT,
                0
            )
            context.enableVertexAttribArray(positionAttribLocation);
            context.enableVertexAttribArray(normalAttribLocation);

            //uniforms
            var u_ModelLocation = context.getUniformLocation(program, "Model")
            var u_ViewLocation = context.getUniformLocation(program, "View")
            var u_ProjectionLocation = context.getUniformLocation(program, "Projection")
            var u_normalMatrixLocation = context.getUniformLocation(program, "normalMatrix")
            var u_lightDirLocation = context.getUniformLocation(program, "lightDir")


            var drawScene = function (timestamp) {

                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                //clear screen
                context.clearColor(0.2, 0.3, 0.8, 1.0)
                context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT)            
                context.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);


                //set shader program
                context.useProgram(program);

                //set uniforms
                let angle = glMatrix.glMatrix.toRadian(timestamp / 10 % 360)

                let Model = glMatrix.mat4.create()
                glMatrix.mat4.rotate(Model, Model, angle, new Float32Array([0, 1, 0]))
                context.uniformMatrix4fv(u_ModelLocation, false, Model)

                let View = glMatrix.mat4.create()
                let eyePos = glMatrix.vec3.fromValues(5, 5, 5)
                let center = glMatrix.vec3.fromValues(0, 0, 0)
                let up = glMatrix.vec3.fromValues(0, 1, 0)
                glMatrix.mat4.lookAt(View, eyePos, center, up)
                context.uniformMatrix4fv(u_ViewLocation, false, View)

                let Projection = glMatrix.mat4.create()
                glMatrix.mat4.perspective(Projection, glMatrix.glMatrix.toRadian(45), canvas.width / canvas.height, 0.1, 1000)
                context.uniformMatrix4fv(u_ProjectionLocation, false, Projection)

                let normalMatrix = glMatrix.mat4.create()
                glMatrix.mat4.multiply(normalMatrix, View, Model)
                glMatrix.mat4.invert(normalMatrix, normalMatrix)
                glMatrix.mat4.transpose(normalMatrix, normalMatrix)
                context.uniformMatrix4fv(u_normalMatrixLocation, false, normalMatrix)

                let lightDir = [-1, -1, 0]
                context.uniform3f(u_lightDirLocation, lightDir[0], lightDir[1], lightDir[2])

                //draw call
                context.drawArrays(context.TRIANGLES, 0, cube.length / 8)

                window.requestAnimationFrame(drawScene)
            }

            context.enable(context.DEPTH_TEST)
            context.enable(context.BLEND)
            window.requestAnimationFrame(drawScene)

        }

        InitGL();
    </script>
</body>