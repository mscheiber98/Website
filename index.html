<!DOCTYPE html>

<head>
    <meta charset="UTF-8">
    <title>WebGL Test</title>
    <script src="J3DIMath.js"></script>
</head>

<body>
    <h1>WebGL Testseite</h1>
    <canvas id="canvas" style="border: 3px solid;" width="500px" height="500px"></canvas>

    <script>
        var vertexShaderSource = `
       precision mediump float;

       attribute vec3 position;
       attribute vec3 normal;

       uniform mat4 MVP;
       uniform mat4 normalMatrix;

       varying vec3 normal_out;
     
       void main(){
           gl_Position = MVP * vec4(position, 1.0);
           normal_out = (normalMatrix * vec4(normal, 1.0)).xyz;

       }
       `
        var fragmentShaderSource = `
       precision mediump float;

       uniform vec3 lightDir;

       varying vec3 normal_out;

       void main(){
        
           float lightInt = max(dot(normal_out, -lightDir), 0.0);
           gl_FragColor = vec4(0.5*lightInt, 0.5*lightInt, 0.5*lightInt, 1.0);
       }
       `

        var InitGL = function () {
            var canvas = document.getElementById("canvas")
            var context = canvas.getContext("experimental-webgl")
            if (!context) {
                alert("Browser does not support WebGL.")
            }

            context.clearColor(0.2, 0.3, 0.8, 1.0)
            context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT)

            //create shaders
            var vertexShader = context.createShader(context.VERTEX_SHADER);
            var fragmentShader = context.createShader(context.FRAGMENT_SHADER);

            context.shaderSource(vertexShader, vertexShaderSource);
            context.shaderSource(fragmentShader, fragmentShaderSource);

            context.compileShader(vertexShader)
            if (!context.getShaderParameter(vertexShader, context.COMPILE_STATUS)) {
                console.error("Error compiling the vertex shader.", context.getShaderInfoLog(vertexShader))
                return
            }

            context.compileShader(fragmentShader)
            if (!context.getShaderParameter(fragmentShader, context.COMPILE_STATUS)) {
                console.error("Error compiling the fragment shader.", context.getShaderInfoLog(fragmentShader))
                return
            }

            //create program, link and check for possible errors
            var program = context.createProgram()
            context.attachShader(program, vertexShader)
            context.attachShader(program, fragmentShader)
            context.linkProgram(program)
            if (!context.getProgramParameter(program, context.LINK_STATUS)) {
                console.error("Error linking program.", context.getProgramInfoLog(program))
                return
            }
            context.validateProgram(program)
            if (!context.getProgramParameter(program, context.VALIDATE_STATUS)) {
                console.error("Error validating program.", context.getProgramInfoLog(program))
                return
            }

            //create triangle and buffers
            var vertices = [
                -0.5, -0.5, 0.0, 0.0, 0.0, 1.0,
                0.5, -0.5, 0.0, 0.0, 0.0, 1.0,
                0.0, 0.5, 0.0, 0.0, 0.0, 1.0,
                
                0.5, -0.5, 0.0, 1.0, 0.0, 0.0,
                0.5, -0.5, -1.0, 1.0, 0.0, 0.0,
                0.5, 0.5, -0.5, 1.0, 0.0, 0.0
            ]
            var vertexBuffer = context.createBuffer()
            context.bindBuffer(context.ARRAY_BUFFER, vertexBuffer)
            context.bufferData(context.ARRAY_BUFFER, new Float32Array(vertices), context.STATIC_DRAW)
            var positionAttribLocation = context.getAttribLocation(program, 'position')
            var normalAttribLocation = context.getAttribLocation(program, 'normal')
            context.vertexAttribPointer(
                positionAttribLocation,
                3,
                context.FLOAT,
                context.FALSE,
                6 * Float32Array.BYTES_PER_ELEMENT,
                0
            )
            context.vertexAttribPointer(
                normalAttribLocation,
                3,
                context.FLOAT,
                context.FALSE,
                6 * Float32Array.BYTES_PER_ELEMENT,
                3 * Float32Array.BYTES_PER_ELEMENT
            )
            context.enableVertexAttribArray(positionAttribLocation);
            context.enableVertexAttribArray(normalAttribLocation);

            //uniforms
            var u_MVPLocation = context.getUniformLocation(program, "MVP")
            var u_normalMatrixLocation = context.getUniformLocation(program, "normalMatrix")
            var u_lightDirLocation = context.getUniformLocation(program, "lightDir")


            var drawScene = function (timestamp) {
                //clear screen
                context.clearColor(0.2, 0.3, 0.8, 1.0)
                context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT)

                //set shader program
                context.useProgram(program);

                //set uniforms
                let MVP = new J3DIMatrix4()
                MVP.makeIdentity()
                let angle = timestamp/10 % 360
                MVP.rotate(angle, 0, 1, 0)
                MVP.setUniform(context, u_MVPLocation, false)

                let normalMatrix = new J3DIMatrix4()
                normalMatrix.load(MVP)
                normalMatrix.invert()
                normalMatrix.transpose()
                normalMatrix.setUniform(context, u_normalMatrixLocation, false)

                let lightDir = [-1, 0, 0]
                context.uniform3f(u_lightDirLocation, lightDir[0], lightDir[1], lightDir[2])

                //draw call
                context.drawArrays(context.TRIANGLES, 0, vertices.length/6)
 
                window.requestAnimationFrame(drawScene)
            }

            window.requestAnimationFrame(drawScene)

        }

        InitGL();
    </script>
</body>